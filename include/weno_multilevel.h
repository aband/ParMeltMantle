#ifndef WENO_MULTILEVEL_H_
#define WENO_MULTILEVEL_H_

#include <vector>
#include <pair>
#include <set>
#include <unordered_set>
#include <array>
#include <valarray>
#include <algorithm>
#include <numeric>
#include <memory>

#include "lapacke.h"
#include "integral.h"
#include <assert.h>

using namespace std;

using point        = valarray<double>;
using point_index  = valarray<int>;
using index_set    = vector<point_index>;
using points_set   = vector<point>;
using stencil      = vector<points_set>;

/*
 *Containing essential information about mesh.
 */
typedef struct {

    int dim;

    vector<int> localsize;   // Local chunck size without ghost layer
    vector<int> localstart;
    vector<int> globalsize;  // global chunck size without ghost layer
    vector<int> ghost_cell;  // size of ghost layer of cell
    vector<int> ghost_vertx; // size of ghost layer of node

    // Horizontal edges first than vertical edges
    int globalEdgeHorizontalSum;
    int localEdgeHorizontalSum;

    // starting at 0 (has not stacked on horizontal edges yet)
    int globalEdgeVerticalSum;
    int localEdgeVerticalSum;

    vector< point > lmesh; 
 
    double** localval;

    // Corner index within a single element
    index_set corner_index_1D {{0}, {1}};
    index_set corner_index_2D {{0,0},{1,0},{1,1},{0,1}};
    index_set corner_index_3D {{0,0,0},{1,0,0},{1,1,0},{0,1,0},
                               {0,0,1},{1,0,1},{1,1,1},{0,1,1}};

} MeshInfo;

template <class T>
class myStencil{
    public:
        myStencil(size_t x): x_(x), stencilSize_(x) {};
        myStencil(size_t x, size_t y): x_(x), y_(y), stencilSize_(x*y) {};
        myStencil(size_t x, size_t y, size_t z): x_(x), y_(y), z_(z), stencilSize_(x*y*z) {};

        void CreateStencil() {stencil_.resize(stencilSize_);}

        T &operator()(size_t i){
            return stencil_[i];
        }

        T &operator()(size_t i, size_t j){
            return stencil_[i+j*x_];
        }

        T &operator()(size_t i, size_t j, size_t k){
            return stencil_[i+j*x_+k*x_*y_];
        }

        vector<T> GetStencil() {return stencil_;}

    private:
        size_t x_;
        size_t y_;
        size_t z_; 
        size_t stencilSize_;
        vector<T> stencil_;
};

/*
 *Define Stencil information used by WENO reconstruction.
 */
class WenoStencil{
    public:
        WenoStencil(const MeshInfo& mi, const int rangex[2], point_index& target);
        WenoStencil(const MeshInfo& mi, const int rangex[2], const int rangey[2], point_index& target);
        WenoStencil(const MeshInfo& mi, const int rangex[2], const int rangey[2],
                                        const int rangez[2], point_index& target);

        ~WenoStencil() {delete [] polyn; delete [] sigma;}
                   //     for (int k=0; k<stencil_size; k++){delete polynderiv_[k];}delete [] polynderiv_;};

        // Update smoothness indicator after each time step
        double ComputeSmoothnessIndicator(const MeshInfo& mi);
        double ComputeSmoothnessIndicator_Simple(const MeshInfo& mi);
        double ComputeSmoothnessIndicator_Polyn(const MeshInfo& mi, int k);

        double Geth() {return h;};

        point GetCenter() {return stencil_center;};

        // Check computed results
        void CheckWenoStencil();
        void PrintBasisPolyn();
        void CheckSigma();

        // ======================================
        point_index targetCell_;

        point_index targetVertx_;

        int stencil_size;

        // Basis polynomial order
        vector<int> polyn_order;

        // Stencil index set generated by index_range
        index_set stencil_index_set;

        // Coefficients of basis polynomial based on given stencil and order.
        double * polyn;

    private:
        // Create coefficients for basis polynomials and
        // corresponding coefficients for derivative of 
        // basis polynomials. 
        void CreateBasisPolyn(const MeshInfo& mi);

        // Create smoothness indicator at the very beginning
        void CreateSigma(const MeshInfo& mi);   // Classical Jiang and Shu Smoothness Indicator

        // Create arbitrary derivative of a given tensor product basis polynomial
        void CreatePolynDerivMulti();
        double * CreateBasisPolynDeriv(int xdegree, int ydegree, int k);

        void CheckPolynDerivMulti();

        /*
         *parameters
         */
        point stencil_center;

        vector<point> center_cell_corners;

        double h;

        // Smoothness indicator.
        double * sigma;

        // Multiplication coefficient matrix of polynomial derivatives
        int ** polynderiv_;
};

class WenoReconstruction{
    public:
        WenoReconstruction(const MeshInfo& mi, vector<double>& linWeights, vector<int *>& rangex, vector<int *>& rangey, point_index& target);

        ~WenoReconstruction() {//for (int i=0; i<linWeights_.size(); i++){delete ws[i];} 
                               //delete ws;
                               }

        void ComputeNonlinWeights(const MeshInfo& mi);

        double PointValueReconstruction(const MeshInfo& mi, point& target);

        // Compute derivative as a reconstruction
        vector<double> PseudoDerivativeWenoReconst(const MeshInfo& mi, point& target);

        // Get private parameters
        double Geth();

        int GetStencilSizeX();
        int GetStencilSizeY();

        index_set GetGlobalCellIndexStencil(const MeshInfo& mi);        

        // Check parameters
        void CheckSigma();

        void CheckNonlinWeights();

        void CheckStencils();

        void CheckSmoothnessIndicator();

        void CheckPolynBasis();

    private:

        vector<double> linWeights_;

        vector<int *> rangex_;
        vector<int *> rangey_;

        point_index target_; 

        vector<WenoStencil *> ws;

        double epsi_ = 1.0;

        vector<double> sigma_;
        vector<double> omega_;
        vector<double> NonLinWeights_;

        // Compute point value reconstruction for each stencil
        double WenoReconstStencil(const MeshInfo& mi, WenoStencil*& ws, point& target);

        // Compute derivative for each stencil
        vector<double> DerivativeWenoReconstStencil(const MeshInfo& mi, WenoStencil*& ws, point& target);
        int StencilIndexMap(int StencilIndex, int localIndex);

};

#endif
